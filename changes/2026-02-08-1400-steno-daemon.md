# Headless Recording Daemon (PR #11)

## Why

The monolithic SwiftTUI app coupled the terminal UI with audio capture, speech recognition, database storage, and AI summarization. This made it impossible to:

- Run transcription in the background without a terminal window
- Build alternative frontends (web, native GUI)
- Keep recording across TUI restarts
- Start transcription at login via launchd

Extracting the backend into a standalone daemon solves all of these.

## How

Created `daemon/` — a separate Swift package containing a headless daemon (`steno-daemon`) that owns all backend responsibilities. The daemon exposes a Unix domain socket with an NDJSON protocol for control and event streaming.

### Architecture

```
steno-daemon (always running)
├── RecordingEngine (actor)
│   ├── AudioSourceFactory → MicrophoneSource / SystemAudioSource
│   ├── SpeechRecognizerFactory → SpeechAnalyzer/SpeechTranscriber
│   └── RollingSummaryCoordinator → Topic extraction + summaries
├── UnixSocketServer
│   ├── CommandDispatcher (start, stop, status, devices, subscribe)
│   └── EventBroadcaster (partial, segment, level, status, topics, error)
├── SQLiteTranscriptRepository (GRDB)
└── Infrastructure (PIDFile, SignalHandler, LaunchdPlist, Paths)
```

### NDJSON Protocol

Commands (client → daemon):
```json
{"cmd":"start","device":"MacBook Pro Microphone","systemAudio":true}
{"cmd":"stop"}
{"cmd":"status"}
{"cmd":"devices"}
{"cmd":"subscribe"}
```

Events (daemon → subscribed clients):
```json
{"event":"partial","text":"hello world","source":"microphone"}
{"event":"segment","text":"Hello world.","source":"microphone","seqNum":1}
{"event":"level","mic":0.42,"sys":0.15}
{"event":"status","recording":true,"sessionId":"..."}
{"event":"topics","sessionId":"..."}
{"event":"error","message":"...","transient":true}
```

### Key Files (82 new files)

| Area | Files | Purpose |
|------|-------|---------|
| Engine | RecordingEngine, SpeechRecognizerFactory, AudioSourceFactory | Core orchestration |
| Socket | UnixSocketServer, DaemonProtocol, ClientConnection | IPC layer |
| Dispatch | CommandDispatcher, EventBroadcaster | Command routing + event fanout |
| Infrastructure | Paths, PIDFile, SignalHandler, LaunchdPlist | Daemon lifecycle |
| CLI | RunCommand, StatusCommand, InstallCommand, UninstallCommand | Entry points |

## Key Decisions

- **Actor-based RecordingEngine** — All mutable state lives in a single actor, eliminating data races. The engine delegates events via `RecordingEngineDelegate` protocol.
- **Protocol-driven DI throughout** — `SpeechRecognizerFactory`, `AudioSourceFactory`, `SocketServer`, `TranscriptRepository`, `PermissionService`, `SummarizationService` are all protocols with mock implementations for testing.
- **SpeechAnalyzer on @MainActor** — Speech.framework crashes with SIGTRAP if `SpeechAnalyzer.start()` is called from a cooperative executor thread. Solution: `ParsableCommand` (not `AsyncParsableCommand`) + `dispatchMain()` to keep the main RunLoop alive, and `Task { @MainActor in }.value` for analyzer startup.
- **NDJSON over HTTP/gRPC** — Unix socket + newline-delimited JSON is the simplest possible IPC. No serialization framework, no code generation, no connection pooling. Each line is a complete message.
- **Shared SQLite schema** — `schema/README.md` documents the database contract. Both daemon and TUI can read the same database (WAL mode allows concurrent readers).

## Testing

- 169 tests across 22 suites, all passing in <1s
- Mocks for every protocol boundary (11 mock types)
- Integration test exercises full command dispatch → engine → event broadcast pipeline

## What's Next

- Go TUI thin client that connects to the daemon (PR #12)
